---
title: "Final Project"
author: "Ryan Chiang"
date: "2024-05-07"
output:
  pdf_document: default
  html_document: default
---
### select for model correctness BIC
#they use seconds moving and bodily contact time to measure activity and affiliation
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("Matrix")
#install.packages("MCMCglmm")
library(Matrix)
#remove.packages("Matrix")
#install.packages("/Users/apple/Downloads/Matrix_1.2-7.1.tar", repos = "NULL", type = "source")
library(dplyr)
library(ggplot2)
library(rptR)
#library(lme4)
library(MCMCglmm)
library(MPV)
library(leaps)
library(MASS)
```

```{r}
wasp <- read.csv("../final_project_STA101/wasp.csv")
```

### https://cran.r-project.org/web/packages/rptR/vignettes/rptR.html

### Repeatability is an important measurement when conducting and analyszing research. Finish doing the repeatability values later. 
```{r}
#summary(wasp)
```



###trying to use lmer function
```{r}
library(lme4)
```

```{r}
lmer_fxn_trial <- lmer(seconds_moving ~ Trial + weight + (1|Wasp.ID), data = wasp)
```

```{r}
summary(lmer_fxn_trial)
```

### model selection

### article and important quote: https://stats.stackexchange.com/questions/231080/can-mcmcglmm-in-r-be-used-similarly-to-lmer
### "MCMCglmm and lmer are both functions that can be used for fitting linear mixed models. MCMCglmm takes a Bayesian approach where priors must be specified for fixed and random effects, enabling inference via Markov Chain Monte Carlo sampling, whereas lmer takes a likelihood approach within the frequentist paradigm."
### include other predictor variables???  potentially take out + Log_aggression + scale(seconds_moving) + anntenation... ask. 



```{r}
lm_model_affiliation <- lm(bodily_contact_time ~ Dummy_Color + Trial + weight + Log_aggression + seconds_moving + anntenation + chambers_entered, data =wasp)
lm_model_affiliation
lm_empty_affiliation_model <- lm(bodily_contact_time ~ 1, data = wasp)
```

```{r}
plot(lm_model_affiliation)
```

```{r}
n = nrow(wasp)
```

```{r}
aff_backward.model.BIC = stepAIC(lm_model_affiliation,  scope = list(lower = lm_empty_affiliation_model, upper= lm_model_affiliation), k = log(n),trace=FALSE,direction = "backward")
aff_forward.model.BIC = stepAIC(lm_empty_affiliation_model,  scope = list(lower = lm_empty_affiliation_model, upper= lm_model_affiliation), k = log(n),direction = "forward")
aff_FB.model.BIC = stepAIC(lm_empty_affiliation_model,  scope = list(lower = lm_empty_affiliation_model, upper= lm_model_affiliation), k = log(n),trace=FALSE,direction = "both")
aff_BF.model.BIC = stepAIC(lm_model_affiliation,  scope = list(lower = lm_empty_affiliation_model, upper= lm_model_affiliation), k = log(n),trace=FALSE,direction = "both")

BIC(aff_backward.model.BIC)
BIC(aff_forward.model.BIC)
BIC(aff_FB.model.BIC)
BIC(aff_BF.model.BIC)

aff_BF.model.BIC
```

```{r}
confint(aff_BF.model.BIC)
```

```{r}
plot(aff_BF.model.BIC)
```






```{r}
lmer_model_affilitation <- lmer(bodily_contact_time ~ Trial + seconds_moving + (1|Wasp.ID), data = wasp)
BIC(lmer_model_affilitation)
```

```{r}

```


```{r}
shapiro.test(resid(lmer_model_affilitation))
```


```{r}
#Group.aff = rep("Lower",nrow(wasp)) #Creates a vector that repeats "Lower" n times
#Group.aff[wasp$bodily_contact_time < median(wasp$bodily_contact_time)] = "Upper" #Changing the appropriate values to "Upper"
#Group.aff = as.factor(Group.aff) #Changes it to a factor, which R recognizes as a grouping variable.
#fligner.test(lmer_model_affilitation$residuals, Group.aff)
```


```{r}
plot(lmer_model_affilitation)
```


```{r}
lm_model_ant <- lm(anntenation ~ Dummy_Color + Trial + weight + Log_aggression + seconds_moving + bodily_contact_time + chambers_entered, data =wasp)
lm_model_ant
lm_empty_ant <- lm(anntenation ~ 1, data = wasp)
```
```{r}
ant_backward.model.BIC = stepAIC(lm_model_ant,  scope = list(lower = lm_empty_ant, upper= lm_model_ant), k = log(n),trace=FALSE,direction = "backward")
ant_forward.model.BIC = stepAIC(lm_empty_ant,  scope = list(lower = lm_empty_ant, upper= lm_model_ant), k = log(n),direction = "forward")
ant_FB.model.BIC = stepAIC(lm_empty_ant,  scope = list(lower = lm_empty_ant, upper= lm_model_ant), k = log(n),trace=FALSE,direction = "both")
ant_BF.model.BIC = stepAIC(lm_model_ant,  scope = list(lower = lm_empty_ant, upper= lm_model_ant), k = log(n),trace=FALSE,direction = "both")
```

```{r}
BIC(ant_backward.model.BIC)
BIC(ant_forward.model.BIC)
BIC(ant_BF.model.BIC)
BIC(ant_FB.model.BIC)
ant_BF.model.BIC
```
```{r}
lmer_model_ant <- lmer(anntenation ~ Log_aggression + (1|Wasp.ID), data = wasp)
```

```{r}
shapiro.test(resid(lmer_model_ant))
```

### try fligner test for this 


###mixed effect model better. 
```{r}
BIC(lmer_model_ant)
```

```{r}
lm_model_agg <- lm(Log_aggression ~ Dummy_Color + Trial + weight + bodily_contact_time + seconds_moving + anntenation + chambers_entered, data =wasp)
lm_model_agg
lm_empty_agg <- lm(Log_aggression ~ 1, data = wasp)
```

```{r}
agg_backward.model.BIC = stepAIC(lm_model_agg,  scope = list(lower = lm_empty_agg, upper= lm_model_agg), k = log(n),trace=FALSE,direction = "backward")
agg_forward.model.BIC = stepAIC(lm_empty_agg,  scope = list(lower = lm_empty_agg, upper= lm_model_agg), k = log(n),direction = "forward")
agg_FB.model.BIC = stepAIC(lm_empty_agg,  scope = list(lower = lm_empty_agg, upper= lm_model_agg), k = log(n),trace=FALSE,direction = "both")
agg_BF.model.BIC = stepAIC(lm_model_agg,  scope = list(lower = lm_empty_agg, upper= lm_model_agg), k = log(n),trace=FALSE,direction = "both")
```
```{r}
BIC(agg_backward.model.BIC)
BIC(agg_forward.model.BIC)
BIC(agg_BF.model.BIC)
BIC(agg_FB.model.BIC)
agg_BF.model.BIC
```

```{r}
lmer_model_agg <- lmer(Log_aggression ~ Dummy_Color + anntenation + (1|Wasp.ID), data = wasp)
lmer_model_agg
```

#Mixed effect model not better 
```{r}
BIC(lmer_model_agg)
```

```{r}
lm_model_exp <- lm(chambers_entered ~ Dummy_Color + Trial + weight + Log_aggression + seconds_moving + bodily_contact_time + anntenation, data =wasp)
lm_model_exp
lm_empty_exp <- lm(chambers_entered ~ 1, data = wasp)
```
```{r}
exp_backward.model.BIC = stepAIC(lm_model_exp,  scope = list(lower = lm_empty_exp, upper= lm_model_exp), k = log(n),trace=FALSE,direction = "backward")
exp_forward.model.BIC = stepAIC(lm_empty_exp,  scope = list(lower = lm_empty_exp, upper= lm_model_exp), k = log(n),direction = "forward")
exp_FB.model.BIC = stepAIC(lm_empty_exp,  scope = list(lower = lm_empty_exp, upper= lm_model_exp), k = log(n),trace=FALSE,direction = "both")
exp_BF.model.BIC = stepAIC(lm_model_exp,  scope = list(lower = lm_empty_exp, upper= lm_model_exp), k = log(n),trace=FALSE,direction = "both")
```

```{r}
BIC(exp_backward.model.BIC)
BIC(exp_forward.model.BIC)
BIC(exp_BF.model.BIC)
BIC(exp_FB.model.BIC)
exp_BF.model.BIC
```

```{r}
shapiro.test(resid(exp_BF.model.BIC))
```

```{r}
Group.exp = rep("Lower",nrow(wasp)) #Creates a vector that repeats "Lower" n times
Group.exp[wasp$chambers_entered < median(wasp$chambers_entered)] = "Upper" #Changing the appropriate values to "Upper"
Group.exp = as.factor(Group.exp) #Changes it to a factor, which R recognizes as a grouping variable.
fligner.test(exp_BF.model.BIC$residuals, Group.exp)
```

##LMER MODEL NOT BETTER. 
```{r}
lmer_model_exp <- lmer(chambers_entered ~ seconds_moving + (1|Wasp.ID), data = wasp)
BIC(lmer_model_exp)
```







```{r}
#install.packages("MPV")
#install.packages("leaps")
library(MPV)
library(leaps)
library(MASS)
#install.packages("lmerTest")
```

```{r}
#lmerTest::step(lmer_model_affilitation_full)
```

```{r}

```

